 设备指纹设计
 
 设备指纹判定依赖于收集的数据，特别是那些带有随机因素的数据，即不向imei、imsi这样的静态数据，但是这些数据同样有用，
（除向imei、mac这样的硬件信息外，还可收集开机时间，cpu温度，电池剩余，内存使用量，安装app列表，app耗电排名待机时间，
连接过的wifi等非机器能控制的因素）

---

传统简单指纹识别：
多_______生______一 (imei,imsi,mac,Bluetooth,……)->mid (其中多（收集的数据个数）是多少不确定，但就算一次），设备保留mid

     |改|
    \   /
一元->二元->三元->四元-> …… 超元N（多（收集的数据）不确定，计算次数也不确定，依赖阈值设定），设备保留（x,元）见后面介绍


设计思想：
基于大多数设备，仅对比几个收集上来的数据就可以得到区分，因此这类设备没有必要收集太多其他数据（如果用于其他用途另说），
那么对于收集不上来的数据对该设备指纹识别的影响就可以忽略了，而且也不用过多的授权，用户体验和安全体验都好。
另外可以减少流量。


数据阈值：
假设默认收集数据个数为M，M可以动态配置，但M是经过运算验证的，不是胡乱设置的，每个设备的M可能不同，由服务器记录和控制。


指纹生成：
从收集的数据提取数据计算，第一次计算一元，服务器后端做对比，去掉那些已经判定唯一的设备，剩下设备计算二元，
以此类推。

    1（（imei，imsi）->mid1 （一元））
--> 2（（mid1， mac）->mid2 （二元）） 下一次加入的数据是mac 还是mem需要经过长期调优验证，尽量减少对比次数，见后面介绍
--> 3 （（mid2， bluetooth）->mid3 （三元））
--> 4（（mid3， mem ）->mid3 （四元））

……

--> N 超元（mid[N],N为最大阈值）

元计算（取哪些数据）
（（mid1， mac）->mid2 （二元））或 （（mid1， mem）->mid2 （二元））都是二元，
那下一次加入的数据是mac还是mem需要经过长期调优验证，最终结果是减少对比次数。

N为元的阈值，N需要经过很多次在服务端计算得出，每个设备可能不一样，由服务器记录，同时下发给客户端。

---  

对比指纹：
一元维度比
二元维度比
三元维度比
……
十元维度比（假设从11开始，剩下设备需要收集特殊数据，逐次增加，而之前设备仅仅收集M=10的数据）
比到超元

---  

设备指纹：
设备唯一性ID = （x, id）， 其中x为几元（如1， 2， 3），id为midx，客户端不关心 midx是由那些数据计算出来的，由服务器控制。

优点：
算法相对简单，但是灵活，数据缺失对结果影响较小，流量相对之前少，指纹各种阈值可动态调节，客户端保留数据简单，
大多数设备可能一元就能对比出来了，丢失无影响，下次计算简单

缺点：
对于一些特殊的恶心的设备要对比多次，并且要收集一些随机的数据（非计算本身静态数据），特别是某些厂商生成的设备从硬件数据
角度对比完全一样的情况。对于对比到超元都区别不出来的设备，可以继续增大这些设备超元的值，收集更多的数据。


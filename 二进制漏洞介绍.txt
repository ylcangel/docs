1、栈溢出，在写缓存区时，未对写入数据大小进行校验，导致写入数据超过缓冲区大小而导致数据溢出覆盖上一级栈数据结构，特别是返回地址。
	不安全函数strcpy、sprintf等
影响：
	任意代码执行
	
#########################################################################################
2、格式化字符串，cwe解释-软件'使用了格式化字符串作为参数'，且'该格式化字符串来自外部输入'，这里格式化字符串是来自外部输入，
	主要就是printf、sprintf、fprintf等print家族函数
	如printf(format, ...), format是要求用户或者外部输入的，但是格式化要求的参数format和实际提供的参数不一致，就导致了漏洞。
影响：
	任意地址读
		printf("%[N]$#x", arg1...argn)-打印第N个参数的二级制值，%N$表示第N个参数, N可以大于n
		printf("%[N]$#x"),打印当前栈顶距离N的内存值，每次%u都会从栈顶弹出一个内存值（stackpop）
		printf("addr|%N$s")-leak mem，addr是我们要读取的buf的地址，N为格式化字符串漏洞的stackpop的步长（视漏洞实际情况定）
		  这里用到了%s，会打印从addr到NUL字节之间所有内存	
	任意地址写（%n)
		printf("%[N]d%n..."{, a<dummy arg>, addr, a1, addr1...}), N为多少*addr的值就为多少，a可以为任意值，{}中的参数可有可无，可以造成任意代码执行
		
#############################################################################################
3、整数溢出，同类型一般溢出都发生在有符号的整数上或者前后传递的整数类型不一致（如 内部定义为int ，外部传入为unsigned int，或者内部为short，外部为int等）
	不安全函数memcpy、strncpy
影响：同堆栈溢出

##############################################################################################
4、双重释放（Double free）
多种利用方式，内存泄露和任意代码执行
##############################################################################################
5、释放后在利用（UAF), 申请一段空间(该空间小于256kb），并将其释放，释放后并不将指针置为空
	应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。
	如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，
	dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。

内存泄露和任意代码执行

##############################################################################################
6、数组越界
7、竞态
8、off-by-one
Stack：
字符串末尾NULL(\00)会覆盖栈上的EBP，所以又称EBP覆写技术。这种技术不会直接覆盖栈上真正的返回地址，
而是在覆盖的EBP指向的内存缓存区（该缓冲区恰好是我们控制的）的区域内构造一个返回地址（一般在覆盖EBP指向位置的上面），
该地址指向任意代码。
	局限：
		1、EBP不在目的缓存区之上，无法利用该技术
		2、对齐空间 - 默认情况下，gcc将堆栈空间对齐为16字节边界，即在创建堆栈空间之前）ESP的最后4位是0并且使用and指令，
		如下面的函数反汇编所示。因此，在这些情况下，在缓冲区buf和EBP的结尾之间找到一个对齐空间（最多12个字节），
		这不允许我们覆盖EBP的LSB！
		3、如果覆盖的EBP指向的地址空间不是我们可控的空间
		
Heap：
单个 NULL 字节会覆盖下一个块的块头部， 只有覆盖size的lsb才能利用，size的lsb是标志位被清空，
漏洞代码会向前合并块，也可以向后合并。执行unlink（large unlink），
利用unlink变换fd、bk、fd_nextsize、bk_nextsize覆盖线程的tls_dtor_list（会在线程exit时执行）

9、堆喷射
		一般应用于浏览器漏洞挖掘
		
		
		
		
		
		
		
		
		
		
		
		
		
		
工具：
ltrace 、 strace 、 gdb 、 objdump （objdump --dynamic-reloc binary， 打印got表）、readelf （readelf	-r	binary,输出重定位表项，包含got）
绕过NX保护：
return to libc、链式return to libc（fake frame，leave ret）、rop
绕过ASLR：
利用plt表项、爆破（fucn_off = libbase + off,地址随机如libc，只随机基地址中的n比特，把所有可能都试一遍）、GOT 覆盖
（将一个GOT表项覆盖为另一个函数的地址）和解引用（似于 GOT 覆盖，但是这里不会覆盖特定 Libc 函数的 GOT 条目，
而是将它的值复制到寄存器中，并将偏移差加到寄存器的内容。
因此，寄存器就含有所需的 Libc 函数地址）、rop
